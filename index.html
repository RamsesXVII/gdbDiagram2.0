<head>
  <!-- Plotly.js -->
  <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
  <script src="https://d3js.org/d3.v4.min.js"></script>
   <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css">
    <script type="text/javascript" src="http://ajax.googleapis.com/ajax/libs/jquery/1.8.3/jquery.min.js"></script>
    <link href="http://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.0.3/css/bootstrap.min.css"
        rel="stylesheet" type="text/css" />
    <script type="text/javascript" src="http://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.0.3/js/bootstrap.min.js"></script>
    <link href="http://cdn.rawgit.com/davidstutz/bootstrap-multiselect/master/dist/css/bootstrap-multiselect.css"
        rel="stylesheet" type="text/css" />
    <script src="http://cdn.rawgit.com/davidstutz/bootstrap-multiselect/master/dist/js/bootstrap-multiselect.js"
        type="text/javascript"></script>

</head>

<body>
  <a class="btn btn-default" href="#" role="button" onclick="getCompressedPlot()">Coompress time</a>
    <a class="btn btn-default" href="#" role="button" onclick="getCompressedPlot()">Uncompress time</a>
<!--    <select id="lstFruits" multiple="multiple"></select>
    <input type="button" id="btnSelected" value="Get the GDBD of Selected Peers. " />-->
  <select id="lstFruits" multiple="multiple" size="5" style="width:100px;">
        </select>
        <input type="button" id="btnSelected" value="Get gdbf of selected peers" />

  <input class="btn btn-default" type="change upstream leve" value="Submit" onclick="getCompressedPlot()">
    <a class="btn btn-default" href="#" role="button" onclick="alert('Click on compressed time button to get a view of the gdbdiagram in terms of sequence of as-path ignoring the time between two consecutive updates.\n Click on uncompress time button to  get a view of the gdbdiagram in terms of sequence of as-path considering the time between two consecutive updates (default).\n The default shows the GDBDiagram of the 5 most unstable collector peers. You can select other collect peers from drop down menu. ')">Help</a>

  <div id="myDiv"><!-- Plotly chart will be drawn inside this DIV --></div>





  <script>


function SetMedia(cpToObservationData) {

  for(cp in cpToObservationData){
      var str="<option>"+cp+" ("+cpToObservationData[cp][2].length+")</option>"
        $("#lstFruits").append(str);
      }
      $(function () {
            $('#lstFruits').multiselect({
                includeSelectAllOption: false
            });
            $('#btnSelected').click(function () {
                var selected = $("#lstFruits option:selected");
                var message = "";
                selected.each(function () {
                    message += $(this).text()+"|";
                });
                getNewVisualization(cpToObservationData,message,"exact");
            });
        });

      }

function getNewVisualization(cpToObservationData,message,typeOfVisualization){
    var nCpToShow=0

    var toVisualize=new Object()
    var splittedMessage = message.split("|");
    for (var i = splittedMessage.length - 1; i >= 0; i--) {
      cp=splittedMessage[i].split(" ")[0].replace(/\s/g, '');
      if(cp!=""){
        nCpToShow=nCpToShow+1
       toVisualize[cp]=cpToObservationData[cp]
      }
    }
    console.log(toVisualize)
    plotDiagram(toVisualize,start,end,resource,typeOfVisualization,idCounter,nCpToShow)

    
}

function updateMostUnstable(mostUnstable,numberOfUpdates,cp,cpToObservationData,minOfMostUnstable,nCpToShow){

  if(Object.keys(mostUnstable).length<nCpToShow)
    mostUnstable[cp]=cpToObservationData[cp]
  
  else{
    for(currentCp in mostUnstable){
      
      currentNumberOfUpdates=mostUnstable[currentCp][2].length
      
      if(currentNumberOfUpdates==minOfMostUnstable){
        delete mostUnstable[currentCp]
        mostUnstable[cp]=cpToObservationData[cp]
        break    
      }
    }
  }
  return mostUnstable
}

function getMinUpdatesCount(mostUnstable){
  currentMin=2000000000000
  
  for(currentCp in mostUnstable){
    currentNumberOfUpdates=mostUnstable[currentCp][2].length
    
    if(currentNumberOfUpdates<currentMin){
      currentMin=currentNumberOfUpdates
    }
  }
  return currentMin
}

function getNMostUnstableCPdata(cpToObservationData,nCpToShow){
  var mostUnstable=new Object()
  var minOfMostUnstable=-1

  for(cp in cpToObservationData){
    numberOfUpdates=cpToObservationData[cp][2].length

    if(numberOfUpdates>minOfMostUnstable){

      mostUnstable=updateMostUnstable(mostUnstable,numberOfUpdates,cp,cpToObservationData,minOfMostUnstable,nCpToShow)
      minOfMostUnstable=getMinUpdatesCount(mostUnstable)
    
    }
  }
  return mostUnstable
}

    
function convertDateFotmate(p1) {
    year=p1.getFullYear().toString()
    month=(p1.getMonth()+1).toString()     
    day=p1.getDate().toString()
    hour=p1.getHours().toString()
    minutes=p1.getMinutes().toString()
    seconds=p1.getSeconds().toString()
    return year+"-"+month+"-"+day+"T"+hour+":"+minutes+":"+  seconds    // The function returns the product of p1 and p2
}

function getParameterByName(name, url) {
    if (!url) url = window.location.href;
      name = name.replace(/[\[\]]/g, "\\$&");
      
    var regex = new RegExp("[?&]" + name + "(=([^&#]*)|&|#|$)"),
        results = regex.exec(url);
    if (!results) return null;
    if (!results[2]) return '';
    return decodeURIComponent(results[2].replace(/\+/g, " "));
}


function plotDiagram(cpToObservationData,start,end,resource,typeOfVisualization,counter,nCpToShow){
      data=[]
      var cpCounter=0
      if(typeOfVisualization=="notCompressed")
        unstableCpToData=getNMostUnstableCPdata(cpToObservationData,nCpToShow)
      else
        unstableCpToData=cpToObservationData
      console.log(unstableCpToData)
      for(cp in unstableCpToData){
        cpCounter=cpCounter+1
        timestampSequence=unstableCpToData[cp][0]//timestamp not compressed, timestampSequence
        timestampSequenceCompressed=unstableCpToData[cp][1]//timestamp compressed, timestampSequenceCompressed
        idSequence=unstableCpToData[cp][2]//idsSequence
        asPathSequence=unstableCpToData[cp][3]//as path sequence

        var colorRandom='#'+(0x1000000+(Math.random())*0xffffff).toString(16).substr(1,6);

        var trace = {
          type: "scatter",
          mode: "lines",
          name: cp.toString(),
          x: timestampSequence,
          y: idSequence,
          line: {color: colorRandom}
        }
        data.push(trace)
      
    }
      var layout = {
        title: 'GDBDiagram of '+resource+' from '+start+' to '+end, 
        xaxis: {
          autorange: true, 
          range: [start, end], 
          rangeselector: {buttons: [
              {
                count: 1, 
                label: '1m', 
                step: 'month', 
                stepmode: 'backward'
              }, 
              {
                count: 6, 
                label: '6m', 
                step: 'month', 
                stepmode: 'backward'
              }, 
              {step: 'all'}
            ]}, 
          rangeslider: {range: [start, end]}, 
          type: 'date'
        }, 
        yaxis: {
          autorange: true, 
          range: [0, counter], 
          type: 'linear'
        }
      };
      Plotly.newPlot('myDiv', data, layout);
}



function getInitialState(json){
    inistialState=json.data.initial_state

    for (var i = 0; i < json.data.sources.length; i++) {
      cp=json.data.sources[i].id
      cpToObservationData[cp]=[]
      cpToObservationData[cp][0]=[]//timestamp not compressed, timestampSequence
      cpToObservationData[cp][1]=[]//timestamp compressed, timestampSequenceCompressed
      cpToObservationData[cp][2]=[]//idsSequence
      cpToObservationData[cp][3]=[]//as path sequence


      cpToObservationData[cp][0].push(start)
      cpToObservationData[cp][1].push(convertDateFotmate(counterTimestampCompressed))
      cpToObservationData[cp][2].push(0)
      cpToObservationData[cp][3].push("W")
     

    }

    for (var i = 0; i < inistialState.length; i++) {
        cp=inistialState[i].source_id

        observationData=cpToObservationData[cp]
        asPath=inistialState[i].path
        cpToObservationData[cp][0]=[start]
        cpToObservationData[cp][1]=[convertDateFotmate(counterTimestampCompressed)]

        id=asPathToId[asPath]

        if(id==undefined){
          asPathToId[inistialState[i].path]=idCounter
          cpToObservationData[cp][2]=[idCounter]
          idCounter=idCounter+100

        }
        else{
          cpToObservationData[cp][2]=[id]
        }

        cpToObservationData[cp][3]=[asPath]
    }
    return cpToObservationData
}

function getEvents(json){

    events=json.data.events

    for (var i = 0; i < events.length; i++) {
      record=events[i]
      cp=record.attrs.source_id
      timestampSequence=cpToObservationData[cp][0]//timestamp not compressed, timestampSequence
      timestampSequenceCompressed=cpToObservationData[cp][1]//timestamp compressed, timestampSequenceCompressed
      idSequence=cpToObservationData[cp][2]//idsSequence
      asPathSequence=cpToObservationData[cp][3]//as path sequence


        if (record.type=="A"){
          path=record.attrs.path
          timestamp=record.timestamp

          prev=idSequence[idSequence.length-1]
          idSequence.push(prev)

          timestampSequence.push(timestamp)

          counterTimestampCompressed.setMinutes(counterTimestampCompressed.getMinutes() + 1);
          timestampSequenceCompressed.push(convertDateFotmate(counterTimestampCompressed))

          prevAsPath=asPathSequence[asPathSequence.length-1]
          asPathSequence.push(prevAsPath)
          asPathSequence.push(path)

          id=asPathToId[path]

          if(id==undefined){
            asPathToId[path]=idCounter
            idSequence.push(idCounter)
            timestampSequence.push(timestamp)
            timestampSequenceCompressed.push(convertDateFotmate(counterTimestampCompressed))
            idCounter=idCounter+100
          }
          else{
            idSequence.push(id)
            timestampSequence.push(timestamp)
           timestampSequenceCompressed.push(convertDateFotmate(counterTimestampCompressed))

          }
         }
         else{
            prevAsPath=asPathSequence[asPathSequence.length-1]
            asPathSequence.push(prevAsPath)
            asPathSequence.push("W")

            timestamp=record.timestamp

            prev=idSequence[idSequence.length-1]

            counterTimestampCompressed.setMinutes(counterTimestampCompressed.getMinutes() + 1);
            timestampSequenceCompressed.push(convertDateFotmate(counterTimestampCompressed))

            idSequence.push(prev)

            timestampSequence.push(timestamp)
            timestampSequenceCompressed.push(convertDateFotmate(counterTimestampCompressed))

            idSequence.push(0)

            timestampSequence.push(timestamp)
            timestampSequenceCompressed.push(convertDateFotmate(counterTimestampCompressed))
         }
      cpToObservationData[cp][0]=timestampSequence//timestamp not compressed, timestampSequence
      cpToObservationData[cp][1]=timestampSequenceCompressed//timestamp compressed, timestampSequenceCompressed
      cpToObservationData[cp][2]=idSequence//idsSequence
      cpToObservationData[cp][3]=asPathSequence//as path sequence
    }
    return cpToObservationData
}

function getEndState(json){

    end=json.data.query_endtime

    for(cp in cpToObservationData){

      timestampSequence=cpToObservationData[cp][0]//timestamp not compressed, timestampSequence
      timestampSequenceCompressed=cpToObservationData[cp][1]//timestamp compressed, timestampSequenceCompressed
      idSequence=cpToObservationData[cp][2]//idsSequence
      asPathSequence=cpToObservationData[cp][3]//as path sequence

      prev=idSequence[idSequence.length-1]
      prevAsPath=asPathSequence[asPathSequence.length-1]

      idSequence.push(prev)
      asPathSequence.push(prevAsPath)
      timestampSequence.push(end)
      timestampSequenceCompressed.push(end)

      cpToObservationData[cp][0]=timestampSequence//timestamp not compressed, timestampSequence
      cpToObservationData[cp][1]=timestampSequenceCompressed//timestamp compressed, timestampSequenceCompressed
      cpToObservationData[cp][2]=idSequence//idsSequence
      cpToObservationData[cp][3]=asPathSequence//as path sequence
    }

    return cpToObservationData
}


resource=getParameterByName("resource")
if(resource==null)
  resource="193.204.167.185"

starttime=getParameterByName("start")
if(starttime==null)
  starttime="1510042362"

endtime=getParameterByName("end")
if(endtime==null)
  endtime="1510215102"

url="https://stat.ripe.net/data/bgplay/data.json?endtime=1510305183&resource=193.204.167.185&rrcs=12&starttime=1510132383&unix_timestamps=TRUE"
//url="https://stat.ripe.net/data/bgplay/data.json?endtime="+endtime+"&resource="+resource+"&rrcs=12&starttime="+starttime+"&unix_timestamps=TRUE"

var idSequence=[]
var timestampSequence=[]
var counterTimestampCompressed=[]
var asPathToId=new Object()
asPathToId["W"]=0
var cpToObservationData=new Object()
var typeOfVisualization="notCompressed"
var nCpToShow=5
var start
var end
var counterTimestampCompressed

d3.json("https://stat.ripe.net/data/bgplay/data.json?resource="+resource, function(error,json){
    start=json.data.query_starttime
    end=json.data.query_endtime


    counterTimestampCompressed=new Date(start)
    idCounter=100

    cpToObservationData=getInitialState(json)
    cpToObservationData=getEvents(json)
    cpToObservationData=getEndState(json)

    plotDiagram(cpToObservationData,start,end,resource,typeOfVisualization,idCounter,nCpToShow)
    SetMedia(cpToObservationData)
})


  </script>

</body>
